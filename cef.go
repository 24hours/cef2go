//generated by: python main.py --go_file=../cef.go --c_file=../cef.c --h_file=cef.h --h_path=../ main.h -I../ 
package chrome 

/*
#cgo CFLAGS: -Wno-incompatible-pointer-types-discards-qualifiers -I./
#include <stdlib.h>
#include "cef_base.h"
#include "cef.h" 
#include "include/capi/cef_app_capi.h"
#include "include/capi/cef_client_capi.h"
#include "include/capi/cef_browser_capi.h"
*/
import "C"
import (
		"unsafe"
)

var AppMap = make(map[unsafe.Pointer]App)

type AppT struct{
	CStruct		*C.cef_app_t
}

func NewAppT(handler App) AppT {
	var ret AppT
	ret.CStruct = (*C.cef_app_t)(C.calloc(1, C.sizeof_cef_app_t))
	C.initializecef_app(ret.CStruct)
	handler.SetAppT(ret)
	AppMap[unsafe.Pointer(ret.CStruct)] = handler
	return ret
}
//Generate by DumpCgoInitializer 


type App interface{
	 GetAppT() AppT 
	 SetAppT(AppT) 
	 OnBeforeCommandLineProcessing(process_type interface{}, command_line interface{})  
	 OnRegisterCustomSchemes(registrar interface{})  
	 GetResourceBundleHandler() interface{} 
	 GetBrowserProcessHandler() interface{} 
	 GetRenderProcessHandler() interface{} 
}
//Generate by DumpGoInterface 

//export go_OnBeforeCommandLineProcessing
func go_OnBeforeCommandLineProcessing (self *C.struct__cef_app_t, process_type *C.cef_string_t, command_line *C.struct__cef_command_line_t)  {
	if handler, ok := AppMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <cef_string_t> process_type 
		//processing CefStructHandler <_cef_command_line_t> command_line 
	  handler.OnBeforeCommandLineProcessing(process_type,command_line)
	}
	
}
//Generate by DumpGoCallBackFunction 

//export go_OnRegisterCustomSchemes
func go_OnRegisterCustomSchemes (self *C.struct__cef_app_t, registrar *C.struct__cef_scheme_registrar_t)  {
	if handler, ok := AppMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_scheme_registrar_t> registrar 
	  handler.OnRegisterCustomSchemes(registrar)
	}
	
}
//Generate by DumpGoCallBackFunction 

//export go_GetResourceBundleHandler
func go_GetResourceBundleHandler (self *C.cef_app_t) *C.struct__cef_resource_bundle_handler_t{
	if handler, ok := AppMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetResourceBundleHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetBrowserProcessHandler
func go_GetBrowserProcessHandler (self *C.cef_app_t) *C.struct__cef_browser_process_handler_t{
	if handler, ok := AppMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetBrowserProcessHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetRenderProcessHandler
func go_GetRenderProcessHandler (self *C.cef_app_t) *C.struct__cef_render_process_handler_t{
	if handler, ok := AppMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetRenderProcessHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

var ClientMap = make(map[unsafe.Pointer]Client)

type ClientT struct{
	CStruct		*C.cef_client_t
}

func NewClientT(handler Client) ClientT {
	var ret ClientT
	ret.CStruct = (*C.cef_client_t)(C.calloc(1, C.sizeof_cef_client_t))
	C.initializecef_client(ret.CStruct)
	handler.SetClientT(ret)
	ClientMap[unsafe.Pointer(ret.CStruct)] = handler
	return ret
}
//Generate by DumpCgoInitializer 


type Client interface{
	 GetClientT() ClientT 
	 SetClientT(ClientT) 
	 GetContextMenuHandler() interface{} 
	 GetDialogHandler() interface{} 
	 GetDisplayHandler() interface{} 
	 GetDownloadHandler() interface{} 
	 GetDragHandler() interface{} 
	 GetFocusHandler() interface{} 
	 GetGeolocationHandler() interface{} 
	 GetJsdialogHandler() interface{} 
	 GetKeyboardHandler() interface{} 
	 GetLifeSpanHandler() LifeSpanHandlerT 
	 GetLoadHandler() interface{} 
	 GetRenderHandler() interface{} 
	 GetRequestHandler() interface{} 
	 OnProcessMessageReceived(browser interface{}, source_process interface{}, message interface{}) int 
}
//Generate by DumpGoInterface 

//export go_GetContextMenuHandler
func go_GetContextMenuHandler (self *C.cef_client_t) *C.struct__cef_context_menu_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetContextMenuHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetDialogHandler
func go_GetDialogHandler (self *C.cef_client_t) *C.struct__cef_dialog_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetDialogHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetDisplayHandler
func go_GetDisplayHandler (self *C.cef_client_t) *C.struct__cef_display_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetDisplayHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetDownloadHandler
func go_GetDownloadHandler (self *C.cef_client_t) *C.struct__cef_download_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetDownloadHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetDragHandler
func go_GetDragHandler (self *C.cef_client_t) *C.struct__cef_drag_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetDragHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetFocusHandler
func go_GetFocusHandler (self *C.cef_client_t) *C.struct__cef_focus_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetFocusHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetGeolocationHandler
func go_GetGeolocationHandler (self *C.cef_client_t) *C.struct__cef_geolocation_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetGeolocationHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetJsdialogHandler
func go_GetJsdialogHandler (self *C.cef_client_t) *C.struct__cef_jsdialog_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetJsdialogHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetKeyboardHandler
func go_GetKeyboardHandler (self *C.cef_client_t) *C.struct__cef_keyboard_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetKeyboardHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetLifeSpanHandler
func go_GetLifeSpanHandler (self *C.cef_client_t) *C.struct__cef_life_span_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetLifeSpanHandler().CStruct
		if ret != nil{
			return ret
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetLoadHandler
func go_GetLoadHandler (self *C.cef_client_t) *C.struct__cef_load_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetLoadHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetRenderHandler
func go_GetRenderHandler (self *C.cef_client_t) *C.struct__cef_render_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetRenderHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_GetRequestHandler
func go_GetRequestHandler (self *C.cef_client_t) *C.struct__cef_request_handler_t{
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		ret := handler.GetRequestHandler()
		if ret != nil{
			return nil
		}
	}
	return nil
}
//Generate by DumpGoGetterFunctions 

//export go_OnProcessMessageReceived
func go_OnProcessMessageReceived (self *C.struct__cef_client_t, browser *C.struct__cef_browser_t, source_process C.cef_process_id_t, message *C.struct__cef_process_message_t) int {
	if handler, ok := ClientMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
		//processing CefStructHandler <cef_process_id_t> source_process 
		//processing CefStructHandler <_cef_process_message_t> message 
	 return handler.OnProcessMessageReceived(browser,source_process,message)
	}
	return 1;
}
//Generate by DumpGoCallBackFunction 

var LifeSpanHandlerMap = make(map[unsafe.Pointer]LifeSpanHandler)

type LifeSpanHandlerT struct{
	CStruct		*C.cef_life_span_handler_t
}

func NewLifeSpanHandlerT(handler LifeSpanHandler) LifeSpanHandlerT {
	var ret LifeSpanHandlerT
	ret.CStruct = (*C.cef_life_span_handler_t)(C.calloc(1, C.sizeof_cef_life_span_handler_t))
	C.initializecef_life_span_handler(ret.CStruct)
	handler.SetLifeSpanHandlerT(ret)
	LifeSpanHandlerMap[unsafe.Pointer(ret.CStruct)] = handler
	return ret
}
//Generate by DumpCgoInitializer 


type LifeSpanHandler interface{
	 GetLifeSpanHandlerT() LifeSpanHandlerT 
	 SetLifeSpanHandlerT(LifeSpanHandlerT) 
	 OnBeforePopup(browser interface{}, frame interface{}, target_url interface{}, target_frame_name interface{}, popupFeatures interface{}, windowInfo interface{}, client Client, settings interface{}, no_javascript_access *int) int 
	 OnAfterCreated(browser interface{})  
	 RunModal(browser interface{}) int 
	 DoClose(browser interface{}) int 
	 OnBeforeClose(browser interface{})  
}
//Generate by DumpGoInterface 

//export go_OnBeforePopup
func go_OnBeforePopup (self *C.struct__cef_life_span_handler_t, browser *C.struct__cef_browser_t, frame *C.struct__cef_frame_t, target_url *C.cef_string_t, target_frame_name *C.cef_string_t, popupFeatures *C.struct__cef_popup_features_t, windowInfo *C.struct__cef_window_info_t, client **C.struct__cef_client_t, settings *C.struct__cef_browser_settings_t, no_javascript_access *C.int) int {
	if handler, ok := LifeSpanHandlerMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
		//processing CefStructHandler <_cef_frame_t> frame 
		//processing CefStructHandler <cef_string_t> target_url 
		//processing CefStructHandler <cef_string_t> target_frame_name 
		//processing CefStructHandler <_cef_popup_features_t> popupFeatures 
		//processing CefStructHandler <_cef_window_info_t> windowInfo 
	  
      go_client, ok := ClientMap[unsafe.Pointer(client)]; 
      if ok == false {
        panic("client is not found in Map")
      }
      		//processing CefStructHandler <_cef_browser_settings_t> settings 
	 go_no_javascript_access := int(*no_javascript_access)
	 return handler.OnBeforePopup(browser,frame,target_url,target_frame_name,popupFeatures,windowInfo,go_client,settings,&go_no_javascript_access)
	}
	return 1;
}
//Generate by DumpGoCallBackFunction 

//export go_OnAfterCreated
func go_OnAfterCreated (self *C.struct__cef_life_span_handler_t, browser *C.struct__cef_browser_t)  {
	if handler, ok := LifeSpanHandlerMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
	  handler.OnAfterCreated(browser)
	}
	
}
//Generate by DumpGoCallBackFunction 

//export go_RunModal
func go_RunModal (self *C.struct__cef_life_span_handler_t, browser *C.struct__cef_browser_t) int {
	if handler, ok := LifeSpanHandlerMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
	 return handler.RunModal(browser)
	}
	return 1;
}
//Generate by DumpGoCallBackFunction 

//export go_DoClose
func go_DoClose (self *C.struct__cef_life_span_handler_t, browser *C.struct__cef_browser_t) int {
	if handler, ok := LifeSpanHandlerMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
	 return handler.DoClose(browser)
	}
	return 1;
}
//Generate by DumpGoCallBackFunction 

//export go_OnBeforeClose
func go_OnBeforeClose (self *C.struct__cef_life_span_handler_t, browser *C.struct__cef_browser_t)  {
	if handler, ok := LifeSpanHandlerMap[unsafe.Pointer(self)]; ok {
		//processing CefStructHandler <_cef_browser_t> browser 
	  handler.OnBeforeClose(browser)
	}
	
}
//Generate by DumpGoCallBackFunction 

