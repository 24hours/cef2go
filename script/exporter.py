import sqlite3, sys, inspect
import settings, utils, cef_parser, cef_enum

def DumpGo(struct, file_d=None, handled_type = None):
  for api in struct.Functions:
    DumpGoFunctions(struct, api, file_d, handled_type=handled_type)

def DumpGoDefinition(struct, file_d=None, handled_type = None):
  file_d = file_d or sys.stdout

  # Perhaps this belong to CGO 
  DumpCgoInitializer(struct, file_d, handled_type=handled_type)

  if isinstance(struct, cef_parser.CefEnum):
    DumpGoEnum(struct, file_d)
  elif isinstance(struct, cef_parser.CefStructHandler):
    DumpGoInterface(struct, file_d, handled_type=handled_type)
  
def DumpC(struct, file_d=None, handled_type = None):
  file_d = file_d or sys.stdout

  for api in struct.Functions:
    DumpCFunctions(api, file_d, handled_type=handled_type)

  DumpCInitializer(struct, file_d, handled_type=handled_type)

def DumpHeader(struct, file_d=None, handled_type=None):
  file_d = file_d or sys.stdout

  DumpExtern(struct, file_d, handled_type=handled_type)

def prepare_file(file_c=None, file_go=None, file_h=None, h_path=None):
  with open(file_c, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('#include "%s" \n' % file_h)
    f.write('#include "_cgo_export.h"\n')
    f.write('\n')

  with open(file_go, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('%s \n' % ('package chrome') )
    f.write('\n')
    f.write('/*\n')
    # golang don't accept const parameter, there is no work around over this. 
    # turn off this warning message to keep the screen clean. 
    f.write('#cgo CFLAGS: -Wno-incompatible-pointer-types-discards-qualifiers -I./\n')
    f.write('#include <stdlib.h>\n')
    f.write('#include "cef_base.h"\n')
    f.write('#include "%s" \n' % file_h)
    f.write('#include "include/capi/cef_app_capi.h"\n')
    f.write('#include "include/capi/cef_client_capi.h"\n')
    f.write('#include "include/capi/cef_browser_capi.h"\n')
    f.write('*/\n')
    f.write('import "C"\n')
    f.write('import (\n')
    f.write('\t\t"unsafe"\n')
    f.write(')\n\n')

  with open(h_path + file_h, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('#include "cef_base.h"\n')
    f.write('#include "include/capi/cef_app_capi.h"\n')
    f.write('#include "include/capi/cef_client_capi.h"\n')

def DumpGoEnum(struct, file_d):
  # type CefValueTypeT int
  # const (
  #    VTYPE_DICTIONARY    CefValueTypeT = 7
  #    VTYPE_STRING        CefValueTypeT = 5
  #    VTYPE_BOOL          CefValueTypeT = 2
  #    VTYPE_BINARY        CefValueTypeT = 6
  #    VTYPE_INT           CefValueTypeT = 3
  #    VTYPE_DOUBLE        CefValueTypeT = 4
  #    VTYPE_NULL          CefValueTypeT = 1
  #    VTYPE_INVALID       CefValueTypeT = 0
  #    VTYPE_LIST          CefValueTypeT = 8
  # )
  
  file_d.write("\ntype %s int\n" % (struct.GoName))
  file_d.write("const (\n")
  for v, k in enumerate(struct.enum_value):
    file_d.write("\t %s \t %s = %s\n" % (k, struct.GoName, struct.enum_value[k]))
  file_d.write(")\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])

def DumpGoInterface(struct, file_d, handled_type=None):
  # type App interface{
  #   GetAppT () AppT 
  #   SetAppT (AppT)
  # 
  #   OnBeforeCommandLineProcessing (process_type String, command_line CommandLine)  
  #   OnRegisterCustomSchemes (registrar SchemeRegistrar)  
  #   GetResourceBundleHandler () ResourceBundleHandler 
  #   GetBrowserProcessHandler () BrowserProcessHandler 
  #   GetRenderProcessHandler () RenderProcessHandler 
  # }

  file_d.write("\ntype %s interface{\n" % (struct.GoName))
  file_d.write('\t Get%sT() %sT \n' % (struct.GoName, struct.GoName ))
  file_d.write('\t Set%sT(%sT) \n' % (struct.GoName, struct.GoName ))
  
  for api in struct.Functions:
    handling = api.TypeStruct in handled_type or api.TypeStruct.instance == 'ctype'
    if api.TypeStruct.instance is not 'ctype' and api.TypeStruct.GoName is not '':
      GoName = api.TypeStruct.GoName+'T'
    else:
      GoName = api.TypeStruct.GoName
    
    file_d.write('\t %s(%s) %s \n' % 
        ( api.GoName, 
          utils.constructGoParamString([ param for param in api.Params if param.name not in ['self'] ], handled_type=handled_type), 
          GoName if handling else api.TypeStruct.GoGeneric))
  file_d.write("}\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])

def DumpCgoInitializer(struct, file_d, handled_type=None):
  # var AppMap = make(map[unsafe.Pointer]App)

  # type AppT struct{
  #   CStruct   *C.cef_app_t
  # }

  # func NewAppT(handler App) AppT {
  #   var ret AppT
  #   ret.CStruct = (*C.cef_app_t)(C.calloc(1, C.sizeof_cef_app_t))
  #   C.initializecef_app(ret.CStruct))
  #   handler.SetAppT(ret)
  #   AppMap[unsafe.Pointer(a.CStruct)] = handler
  #   return ret
  # }

  cstruct_name = "CStruct"

  file_d.write("var %sMap = make(map[unsafe.Pointer]%s)\n" % 
        ( struct.GoName,
          struct.GoName))

  file_d.write("\ntype %sT struct{\n" % struct.GoName)
  file_d.write("\t%s\t\t*C.%s\n" % (cstruct_name, utils.getStructName(struct.name, type=None)))
  file_d.write("}\n")

  file_d.write("\nfunc New%sT(handler %s) %sT {\n" % (struct.GoName, struct.GoName, struct.GoName))
  file_d.write("\tvar ret %sT\n" % struct.GoName)
  file_d.write("\tret.%s = (*C.%s)(C.calloc(1, C.sizeof_%s))\n" % 
      ( cstruct_name, 
        utils.getStructName(struct.name, type=None), 
        utils.getStructName(struct.name, type=None)))
  file_d.write("\tC.%s(ret.%s)\n" % (settings.init_prefix+utils.getStructName(struct.name), cstruct_name))
  file_d.write("\thandler.Set%sT(ret)\n" % (struct.GoName))
  file_d.write("\t%sMap[unsafe.Pointer(ret.%s)] = handler\n" % (struct.GoName, cstruct_name))
  file_d.write("\treturn ret\n")
  file_d.write("}\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])


def DumpCInitializer(struct, file_d, handled_type=None):
  # void initializecef_app ( cef_app_t * self){
  #   self->base.size = sizeof(cef_app_t);
  #   initialize_cef_base((cef_base_t*) self);
  #
  #   self->on_before_command_line_processing = on_before_command_line_processing;
  #   self->on_register_custom_schemes = on_register_custom_schemes;
  #   self->get_resource_bundle_handler = get_resource_bundle_handler;
  #   self->get_browser_process_handler = get_browser_process_handler;
  #   self->get_render_process_handler = get_render_process_handler;
  # }

  file_d.write('void %s ( %s * self){\n' % ( settings.init_prefix+utils.getStructName(struct.name), 
                                             utils.getStructName(struct.name, type=None) ))
  file_d.write('\tself->base.size = sizeof(%s);\n' % (utils.getStructName(struct.name, type=None)) )
  file_d.write('\tinitialize_cef_base((cef_base_t*) self);\n') 
  for api in struct.Functions:
    file_d.write('\tself->%s = %s;\n' % (api.name , api.name))
  file_d.write('}\n')
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])

def DumpCFunctions(func_struct, file_d, handled_type=None):
  if func_struct.Purpose is cef_enum.Function.STRUCT_METHOD:
    DumpFunctionAsAPI(func_struct, file_d, handled_type=handled_type)
  else:
    DumpFunctionAsHandler(func_struct, file_d, handled_type=handled_type)


def DumpFunctionAsAPI(func_struct, file_d, handled_type=None):
  # void CEF_CALLBACK on_before_command_line_processing (
  #    struct _cef_app_t          *  self, 
  #    const cef_string_t         *  process_type, 
  #    struct _cef_command_line_t *  command_line){
  # }

  file_d.write('%s CEF_CALLBACK %s %s (%s){\n' % 
      ( func_struct.TypeStruct.name,
        '' if func_struct.pointer is None else '*', 
        func_struct.name, 
        utils.constructParamString(func_struct.Params) ))
  # TODO : include this line back 
  #file_d.write('\treturn %s(%s)\n' % (golang_prefix + self.name , ','.join([ i.name for i in self.param_detail ])))
  # remove this line 
  if func_struct.TypeStruct.CReturn != '':
    file_d.write('\t%s\n' % func_struct.TypeStruct.CReturn) 
  file_d.write('}\n')
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])


def DumpFunctionAsHandler(func_struct, file_d, handled_type=None):
  # struct _cef_render_process_handler_t * CEF_CALLBACK get_render_process_handler(struct _cef_app_t *  self){
  #   return go_GetRenderProcessHandler(self);
  # }

  file_d.write("%s %s CEF_CALLBACK %s(%s){\n" % 
    ( func_struct.type, 
      func_struct.pointer or '', 
      func_struct.name, 
      utils.constructParamString(func_struct.Params) ))
  file_d.write("")

  file_d.write("\treturn %s%s(%s);\n" % 
      ( settings.golang_prefix, 
        func_struct.GoName, 
        # normally the param should really contain only self.
        # this method ensure I won't miss anything incase my assumption is wrong
        # however this methods is alittle hacky
        ','.join(p.name for p in func_struct.Params)))
  file_d.write("}\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])

def DumpGoFunctions(struct, func_struct, file_d, handled_type=None):
  if func_struct.Purpose in [ cef_enum.Function.CALLBACK_EVENT, cef_enum.Function.STRUCT_METHOD ]:  
    DumpGoCallBackFunction(struct, func_struct, file_d, handled_type=handled_type)
  else:
    DumpGoGetterFunctions(struct, func_struct, file_d, handled_type=handled_type)

def DumpGoCallBackFunction(struct, func_struct, file_d, handled_type=None):
  file_d.write("//export %s%s\n" % (settings.golang_prefix, func_struct.GoName))

  param_string = []
  for p in func_struct.Params:
    param_string.append(p.name + ' ' +  p.pointer + 'C.' + p.TypeStruct.CgoName)

  file_d.write("func %s%s (%s) %s {\n" % 
      ( settings.golang_prefix, 
        func_struct.GoName, 
        ', '.join(param_string), 
        func_struct.TypeStruct.GoName))
  file_d.write("\tif handler, ok := %sMap[unsafe.Pointer(%s)]; ok {\n" % (struct.GoName, func_struct.Params[0].name))
  
  param_name_list = []
  for param in func_struct.Params[1:]:
    if param.TypeStruct in handled_type or param.TypeStruct.instance == 'ctype':
      file_d.write("\t %s" % (param.TypeStruct.CToGoConversion(param.name, "go_"+param.name)))
      if param.TypeStruct.instance == 'ctype' and param.TypeStruct.pointer == '*':
        param_name_list.append("&go_"+param.name)
      else:
        param_name_list.append("go_"+param.name)
    else:
      file_d.write("\t\t//processing %r %s \n" % (param.TypeStruct, param.name))
      param_name_list.append(param.name)

  if func_struct.TypeStruct.name == 'void':
    return_flag = ""
  else:
    return_flag = "return"

  file_d.write("\t %s handler.%s(%s)\n" % 
      ( return_flag, 
        func_struct.GoName, 
        ','.join([ param for param in param_name_list ]) ))    

  file_d.write("\t}\n")
  file_d.write("\t%s\n" % func_struct.TypeStruct.CReturn)
  file_d.write("}\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])

def DumpGoGetterFunctions(struct, func_struct, file_d, handled_type=None):
  cstruct_name = "CStruct"

  file_d.write("//export %s%s\n" % (settings.golang_prefix, func_struct.GoName))
  file_d.write("func %s%s (self *C.%s) *C.%s{\n" % 
      ( settings.golang_prefix, 
        func_struct.GoName, 
        utils.getStructName(struct.name, type=None), 
        func_struct.TypeStruct.CgoName))
  file_d.write("\tif handler, ok := %sMap[unsafe.Pointer(self)]; ok {\n" % (struct.GoName))
  if func_struct.TypeStruct in handled_type:
    file_d.write("\t\tret := handler.%s().%s\n" % (func_struct.GoName, cstruct_name))
  else:
    file_d.write("\t\tret := handler.%s()\n" % (func_struct.GoName))
  file_d.write("\t\tif ret != nil{\n")

  if func_struct.TypeStruct in handled_type:#  or func_struct.TypeStruct.instance is 'ctype':
    file_d.write("\t\t\treturn ret\n")
  else:
    file_d.write("\t\t\treturn %s\n" % (func_struct.TypeStruct.GoGenericVal))
  file_d.write("\t\t}\n")
  file_d.write("\t}\n")
  file_d.write("\treturn nil\n")
  file_d.write("}\n")
  file_d.write("//Generate by %s \n\n" % inspect.stack()[0][3])


def DumpExtern(struct, file_d, handled_type=None):
  file_d.write('void %s ( %s * self);\n' % 
      ( settings.init_prefix+utils.getStructName(struct.name), 
        utils.getStructName(struct.name, type=None) ))







