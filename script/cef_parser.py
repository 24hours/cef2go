from clang.cindex import Index, Config, CursorKind
from pprint import pprint
Config.set_library_path('/Library/Developer/CommandLineTools/usr/lib')
from optparse import OptionParser, OptionGroup
import sqlite3
import sys, re, os.path
from enum import Enum
from cef_util import node_info, dump_node, getStructName, camelCase, Struct, Function, getIdbyName
import utils

db_name = "cef.db"
init_prefix = "initialize"
golang_prefix = "go_"
data_type = []
GoToC = {
  'cef_string_t' : {'name' : 'String' ,
                    'converter' : None
                    } 
}

conn = sqlite3.connect(db_name)
c = conn.cursor()

def prepare_file(file_c=None, file_go=None, file_h=None, h_path=None):
  with open(file_c, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('#include "%s" \n' % file_h)
    f.write('#include "_cgo_export.h"\n')
    f.write('\n')

  with open(file_go, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('%s \n' % ('package chrome') )
    f.write('\n')
    f.write('/*\n')
    # golang don't accept const parameter, there is no work around over this. 
    # turn off this warning message to keep the screen clean. 
    f.write('#cgo CFLAGS: -Wno-incompatible-pointer-types-discards-qualifiers -I./\n')
    f.write('#include <stdlib.h>\n')
    f.write('#include "cef_base.h"\n')
    f.write('#include "%s" \n' % file_h)
    f.write('#include "include/capi/cef_app_capi.h"\n')
    f.write('#include "include/capi/cef_client_capi.h"\n')
    f.write('#include "include/capi/cef_browser_capi.h"\n')
    f.write('*/\n')
    f.write('import "C"\n')
    f.write('import (\n')
    f.write('\t\t"unsafe"\n')
    f.write(')\n\n')

  with open(h_path + file_h, 'w') as f:
    f.write('%s %s \n' % ('//generated by: python', ' '.join([ cmd for cmd in sys.argv ])))
    f.write('#include "cef_base.h"\n')
    f.write('#include "include/capi/cef_app_capi.h"\n')
    f.write('#include "include/capi/cef_client_capi.h"\n')

def reset_db():
  c.execute('DROP TABLE IF EXISTS node');
  c.execute('''CREATE TABLE node
             (hash Integer, parent_hash Integer, kind text, spelling text, type_spelling text, type_kind_spelling text, enum_value text, definition text, file text, line_no Integer, kind_id Integer)''')
  conn.commit()

def save_node(node, parent):
  c.execute('SELECT * FROM node WHERE hash=?', (node.hash, ))
  
  node_detail = node_info(node, parent)
  c.execute('INSERT INTO node VALUES (?,?,?,?,?,?,?,?,?,?, ?)', node_detail)
  conn.commit()
  for child in node.get_children():
    save_node(child, node)
  return

# ---------------------------== Code begin ==-------------------------
def ConstructStruct(hash_id):
  c.execute('SELECT DISTINCT * FROM node WHERE hash = ?', (hash_id,))
  record = c.fetchone()
  if record[2] == 'CursorKind.ENUM_DECL':
    return CefEnum(hash_id)
  else:
    return CefStructHandler(hash_id)

class CefStruct(object):
  def __init__(self, hash_id):
    self.hash = hash_id
    c.execute('SELECT * FROM node WHERE hash = ?', (hash_id,))
    row = c.fetchone()
    self.name = row[3]
    self.type = row[4]
    self.instance = 'cefstruct'

  def __hash__(self):
    return hash(self.name)

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.name == other
    else:
      return self.name == other.name

  @property
  def CgoName(self):
    if self.name[0] == '_':
      return 'struct_' + ''.join(self.name.split(' '))
    else:
      return self.name

  def DumpC(all=False):
    raise Exception('Dump C is Not Implemented')

  def DumpGo(all=False):
    raise Exception('Dump Go is Not Implemented')

class CefStructHandler(CefStruct):
  def __init__(self, hash_id):
    c.execute('SELECT DISTINCT * FROM node WHERE hash = ?', (hash_id,))
    record = c.fetchone()
    if record[2] == 'CursorKind.ENUM_DECL':
      raise Exception('CefStructHandler failed to handle Enumeration')

    super(CefStructHandler, self).__init__(hash_id)

  def __repr__(self):
    return 'CefStructHandler <%s>' % self.name

  @property
  def GoName(self):
    if self.name in GoToC:
      return GoToC[self.name]['name']
    else:
      return camelCase(getStructName(self.name[1:]), capital=True)

  @property
  def Functions(self):
    c.execute('SELECT DISTINCT * FROM node WHERE kind != ? AND spelling != ? AND parent_hash = ?', ('CursorKind.UNEXPOSED_ATTR', 'base', self.hash,))
    return [ CefFunction(api[0]) for api in c.fetchall() ]

  @property
  def GoGeneric(self):
    return "interface{}"

  @property
  def GoGenericVal(self):
    return "nil"

  @property
  def CGoGeneric(self):
    return "unsafe.pointer"

class CefParam(CefStruct):
  def __init__(self, hash_id):
    self.hash = hash_id
    c.execute('SELECT DISTINCT * FROM node WHERE hash = ?', (hash_id,))  
    param = c.fetchone()
    self.string = param[4]
    self.name = param[3]
    c.execute('SELECT DISTINCT * FROM node WHERE parent_hash = ?', (hash_id,))
    param_type = c.fetchone()
    
    if param_type is not None:
      self.type_id = param_type[10]
      self.type = param_type[3]
      self.const = True if re.search('const', param[4]) is not None else False
      self.pointer = param[4].replace(param_type[3],'').strip().split(' ')[-1]
      self.native = False
    else:
      # print "Native type found in %d" % self.hash
      # I don't exactly know what happen here. 
      self.type_id = hash_id
      self.type = param[4]
      self.const = True if re.search('const', param[4]) is not None else False
      self.pointer = ''
      self.native = True # native ctype

  def __repr__(self):
    return "CefParam <<%r> %s>" % (self.TypeStruct, self.name)

  @property
  def isPointer(self):
    return False if self.pointer is '' else True

  @property
  def isConstant(self):
    return self.const

  @property
  def TypeStruct(self):
    if not self.native:
      return ConstructStruct(self.type_id)
    else:
      return CType(self.type)
      # raise Exception("Native type (%s)parsing not implemented" % self.type )

class CefFunction(object):
  def __init__(self, function_id):
    self.id = function_id
    c.execute('SELECT DISTINCT * FROM node WHERE kind != ? and spelling != ? and hash = ?', ('CursorKind.UNEXPOSED_ATTR', 'base', function_id,))
    api = c.fetchone()
    self.name = api[3]
    if api[5] == 'Pointer':
      type_spelling = api[4].split('(*)')
      c.execute('SELECT DISTINCT * FROM node WHERE kind = ? AND parent_hash = ?', ('CursorKind.TYPE_REF', api[0],))
      function_type = c.fetchone()
      if function_type is not None:
        self.type = function_type[3]
        self.pointer = type_spelling[0].replace(function_type[3], '').strip() 
      else:
        self.type = type_spelling[0].strip()
        self.pointer = None
    else:
      self.type = api[4].strip()
      self.pointer = None
      # raise Exception(api[0], api[3], 'is not function pointer')
  
  def __repr__(self):
    return 'CefFunction < %r %s >' % (self.TypeStruct, self.name)

  @property
  def TypeStruct(self):
    # naive way to detect if type is native
    if 'struct' in self.type or 'cef' in self.type:
      return ConstructStruct(getIdbyName(getStructName(self.type, type=None), db_name))
    else:
      return CType(self.type)

  @property
  def Purpose(self):
    if re.match('get_.*_handler',self.name) is not None:
      return Function.HANDLER_GETTER
    elif re.match('on_.*', self.name) is not None:
      return Function.CALLBACK_EVENT
    else:
      return Function.STRUCT_METHOD

  @property 
  def Params(self):
    c.execute('SELECT DISTINCT * FROM node WHERE kind = ? AND parent_hash = ?', ('CursorKind.PARM_DECL', self.id,))
    return [ CefParam(row[0]) for row in c.fetchall() ] 

  def DumpGo(self, all=False):
    raise Exception('Dump Go is Not Implemented')

  # this dont belong here
  @property
  def GoName(self):
    return camelCase(self.name, capital=True)

class CType(object):
  def __init__(self, name):
    self.name = name.strip()
    self.instance = 'ctype'

  def __hash__(self):
    return hash(self.name)

  def __eq__(self, other):
    if isinstance(other, basestring):
      return self.name == other
    else:
      return self.name == other.name

  def __repr__(self):
    return 'CType < %s >' % self.name

  @property
  def GoName(self):
    if self.name == 'void':
      return ''
    elif self.name == 'int':
      return 'int'

  @property
  def CReturn(self):
    if self.name == 'int':
      return 'return 1;'
    return ''

  def typeHandling(self):
    raise Exception('Not Implemented')

class CefType(CType, CefStruct):
  def __init__(self, hash_id):
    super(CefType, self).__init__(hash_id)
    c.execute("SELECT DISTINCT * FROM node WHERE hash=?", (hash_id,))
    original  = c.fetchone()
    self.hash = original[0]
    c.execute("SELECT DISTINCT * FROM node WHERE kind != 'CursorKind.UNEXPOSED_ATTR' AND spelling != 'base' AND parent_hash=?", (original[0],))
    self.function_pointer = []
    for api in c.fetchall():
      self.function_pointer.append(CefFunction(api[0]))
    self.hash = original[0]

class CefEnum(CType, CefStruct):
  def __init__(self, hash_id):
    c.execute("SELECT DISTINCT * FROM node WHERE hash=?", (hash_id,))
    original  = c.fetchone()
    self.hash = original[0]
    self.name = original[4]
    c.execute("SELECT DISTINCT * FROM node WHERE parent_hash=?", (original[0],))
    self.enum_value = {}
    for api in c.fetchall():
      self.enum_value[api[3]] = api[6]

  def __repr__(self):
    return 'CefEnum <%s>' % self.name

  @property
  def GoName(self):
    return camelCase(self.name, capital=True)
  
  @property
  def CgoName(self):
    return self.name

def DumpGo(struct, file_d=None, handled_type = None):
  file_d = file_d or sys.stdout

  # Perhaps this belong to CGO 
  utils.DumpCgoInitializer(struct, file_d, handled_type=handled_type)

  if isinstance(struct, CefEnum):
    utils.DumpGoEnum(struct, file_d)
  elif isinstance(struct, CefStructHandler):
    utils.DumpGoInterface(struct, file_d, handled_type=handled_type)

  for api in struct.Functions:
    utils.DumpGoFunctions(struct, api, file_d, handled_type=handled_type)

    
def DumpC(struct, file_d=None, handled_type = None):
  file_d = file_d or sys.stdout

  for api in struct.Functions:
    utils.DumpCFunctions(api, file_d, handled_type=handled_type)

  utils.DumpCInitializer(struct, file_d, handled_type=handled_type)

def DumpHeader(struct, file_d=None, handled_type=None):
  file_d = file_d or sys.stdout

  utils.DumpExtern(struct, file_d, handled_type=handled_type)

def recursive_search(struct, known_struct = set()):
  if struct in known_struct:
    return known_struct 

  if isinstance(struct, CType):
    known_struct.add(struct)
    return known_struct 

  for f in struct.Functions:
    known_struct.add(struct)
    known_struct = recursive_search(f.TypeStruct, known_struct)
    for p in f.Params:
      known_struct.add(struct)
      known_struct = recursive_search(p.TypeStruct, known_struct)

  return known_struct

if __name__ == '__main__':
  '''
  script use to generate c to golang binding
  it will contain alot of error, but will be modified as fit.
  '''
 
  parser = OptionParser("usage: %prog [options] {filename} [clang-args*]")
  parser.add_option("-g", "--go_file", dest="go_file",
                  help="write generated go code to FILE", metavar="FILE")
  parser.add_option("-c", "--c_file", dest="c_file",
                  help="write generated c code to FILE", metavar="FILE")
  parser.add_option("-d", "--h_file", dest="h_file",
                  help="write generated header code to FILE", metavar="FILE")
  parser.add_option("-p", "--h_path", dest="h_path",  
                  help="path for generated header code", metavar="FILE")
  parser.add_option("-r", "--reload", action="store_true", dest="refresh",
                  help="force refresh on the database")
  parser.add_option("-v", "--verbose", action="store_true", dest="verbose",
                  help="print the dumped node to console")
  
  parser.disable_interspersed_args()
  (opts, args) = parser.parse_args()

  prepare_file(file_c=opts.c_file, file_go=opts.go_file, file_h=opts.h_file, h_path=opts.h_path)

  if len(args) == 0:
      parser.error('invalid number arguments')

  if opts.refresh:
    index = Index.create()
    tu = index.parse(None, args)
    if not tu:
        parser.error("unable to load input")

    reset_db()
    save_node(tu.cursor, None)
    if opts.verbose:
      pprint(dump_node(tu.cursor, None))
    
  struct_type = {}

  # starting from entry point : cef_app_t 
  # any struct referenced by "cef_app_t" will get parser.
  app_id = getIdbyName('cef_app_t', db_name)
  client_id = getIdbyName('cef_client_t', db_name)

  app = CefStructHandler(app_id)
  client = CefStructHandler(client_id)

  with open(opts.c_file, "a") as f:
    DumpC(app, file_d = f, handled_type = ['_cef_app_t', '_cef_client_t'])
    DumpC(client, file_d = f,  handled_type = ['_cef_app_t', '_cef_client_t'])
    
  with open(opts.go_file, "a") as f:
    DumpGo(app, file_d = f,  handled_type = ['_cef_app_t', '_cef_client_t'])
    DumpGo(client, file_d = f,  handled_type = ['_cef_app_t', '_cef_client_t'])

  with open(opts.h_path + opts.h_file, 'a') as f:
    DumpHeader(app, file_d = f,  handled_type = ['_cef_app_t', '_cef_client_t'])
    DumpHeader(client, file_d = f,  handled_type = ['_cef_app_t', '_cef_client_t'])

  # # collect all public struct that should be parsed 
  # struct_list = recursive_search(app)
  # struct_list.union(recursive_search(client))
  
  # for p in struct_list:
  #   if isinstance(p, CefEnum):   
  #     # DumpGo(p)
  #     pass
  #   elif p == '_cef_app_t':
  #     DumpGo(p)

