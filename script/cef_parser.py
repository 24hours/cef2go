from clang.cindex import Index, Config, CursorKind
from pprint import pprint
Config.set_library_path('/Library/Developer/CommandLineTools/usr/lib')
from optparse import OptionParser, OptionGroup
import sqlite3
import sys, re
from enum import Enum

db_name = "cef.db"
file_go = "_cef.go"
file_c = "_cef.c"
init_prefix = "initialize_"
golang_prefix = "go_"
data_type = []

conn = sqlite3.connect(db_name)
c = conn.cursor()

def prepare_file():
  with open(file_c, 'w') as f:
    f.write('%s %s \n' % ('//generated by ', sys.argv[0]) )
    f.write('%s \n' % ('#include "../include/capi/cef_app_capi.h"') )
    f.write('%s \n' % ('#include "../include/capi/cef_client_capi.h"') )
    f.write('\n\n')

  with open(file_go, 'w') as f:
    f.write('%s %s \n' % ('//generated by ', sys.argv[0]) )
    f.write('%s \n' % ('package chrome') )
    f.write('import(\n')
    f.write('"C"\n')
    f.write(')\n')

def reset_db():
  c.execute('DROP TABLE IF EXISTS node');
  c.execute('''CREATE TABLE node
             (hash Integer, parent_hash Integer, kind text, spelling text, type_spelling text, type_kind_spelling, file text, line_no Integer)''')
  conn.commit()

def save_node(node, parent):
  c.execute('SELECT * FROM node WHERE hash=?', (node.hash, ))
  
  node_detail = node_info(node, parent)
  c.execute('INSERT INTO node VALUES (?,?,?,?,?,?,?,?)', node_detail)
  conn.commit()
  for child in node.get_children():
    save_node(child, node)
  return

def node_info(node, parent):
  if node is None:
    return (0, 0, "", "","","",0)
  else:
    if node.location.file is not None:
      filename = node.location.file.name 
      filename = filename.split('/')
      filename = filename[-1]
    else:
      filename = ""
    return (node.hash, parent.hash if parent is not None else 0, str(node.kind), node.spelling, node.type.spelling, node.type.kind.spelling, filename, node.location.line)

def dump_node(node, parent):
  '''
  node : {clang.Cursor}
    a node in AST 
  depth : {int}
    depth of the node to be dumped
  call_back : {list}
    a list of function with the format function(node), return true and the node will be saved. 
  '''

  children = [dump_node(c, node) for c in node.get_children()]
  #if ( node.kind is CursorKind.TYPEDEF_DECL and node.is_definition() is True ) or node.kind is CursorKind.FUNCTION_DECL:
  #  print node.kind ,','  ,node.spelling,',', node.location.file.name, ',' , node.location.line
  

  return { 'parent' : parent.hash if parent is not None else 0,
           'hash' : node.hash,
           'kind_name' : type(node),
           'kind' : node.kind,
           'type' : node.type,
           'type_kind' : node.type.kind.spelling, 
           'type_spelling' : node.type.spelling,
           'translation_spelling' : node.translation_unit.spelling,
           'spelling' : node.spelling,
           'location' : node.location,
           'is_definition' : node.is_definition(),
           'enum' : type(node.type) ,
           'referenced' : node.referenced.hash if node.referenced is not None else 0,
           'children' : children }

# ---------------------------== Code begin ==-------------------------
class Function(Enum):
  API = 0
  HANDLER_GETTER = 1
  STRUCT_METHOD = 2


class CefStruct(object):
  def __init__(self):
    pass

  def getStructHeader(self, hash_id):
    c.execute("select * from node where hash=?", (hash_id,))
    row = c.fetchone()
    ret = {}
    ret['id'] = row[0]
    ret['name'] = row[3]
    ret['type'] = row[4]
    
    return ret

  def DumpC(all=False):
    raise Exception('Dump C is Not Implemented')

  def DumpGo(all=False):
    raise Exception('Dump Go is Not Implemented')

class CefStructHandler(CefStruct):
  def __init__(self, hash_id):
    c.execute("select * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and spelling != 'base' and parent_hash=?", (hash_id,))
    # UNEXPOSED_ATTR mostly reference to CEF_CALLBACK, which is not really helpful in parsing.
    original = c.fetchone()
    c.execute("select distinct * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and spelling != 'base' and parent_hash=?", (original[0],))
    self.function_pointer = []
    for api in c.fetchall():
      self.function_pointer.append(CefFunction(api[0]))
    self.struct_header = self.getStructHeader(hash_id)
   
  def _dumpFunctions(self, file_d=None):
    if file_d is None:
      file_d = sys.stdout

    for api in self.function_pointer:
      api.DumpC(file_d)
    
  def _dumpInitializer(self, file_d=None):
    if file_d is None:
      file_d = sys.stdout

    #app_api_initializer
    file_d.write('void %s ( %s * self){\n' % ( init_prefix+self.struct_header['name'], self.struct_header['type'] ))
    file_d.write('\tself->base.size = sizeof(%s);\n' % (self.struct_header['type']) )
    file_d.write('\tinitialize_cef_base((cef_base_t*) self);\n') 
    for api in self.function_pointer:
      file_d.write('\tself->%s = %s;\n' % (api.name , api.name))
    file_d.write('}\n\n')

  def DumpC(self, file_d=None):
    self._dumpFunctions(file_d=file_d)
    self._dumpInitializer(file_d=file_d)

class CefParam(CefStruct):
  def __init__(self, hash_id):
    c.execute("select distinct * from node where hash=?", (hash_id,))  
    row = c.fetchone()
    self.string = row[4]
    self.name = row[3]
    c.execute("select distinct * from node where parent_hash=?", (hash_id,))
    param_type = c.fetchone()
    
    if param_type is not None:
      self.type = param_type[3]
      self.const = True if re.search('const', row[4]) is not None else False
      self.pointer = row[4].replace(param_type[3],'').strip().split(' ')[-1]
    else:
      self.type = row[4]
      self.const = False
      self.pointer = ''

  @property
  def isPointer(self):
    return False if self.pointer is '' else True

  @property
  def isConstant(self):
    return self.const

class CefFunction(object):
  def __init__(self, function_id):
    self._getFunction(function_id)
    self._getFunctionParam(function_id)
  
  @property
  def Purpose(self):
    if re.match('get_.*_handler',self.name) is not None:
      return Function.HANDLER_GETTER
    elif re.match('on_.*', self.name) is not None:
      return Function.API
    else:
      return Function.STRUCT_METHOD

  def _getFunctionParam(self, function_hash):
    c.execute("select distinct * from node where kind = 'CursorKind.PARM_DECL' and parent_hash=?", (function_hash,))
    ret = []
    for row in c.fetchall():
      param_detail = CefParam(row[0])
      ret.append(param_detail)

    self.param_detail = ret    

  def _getFunction(self, hash_id):
    c.execute("select distinct * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and spelling != 'base' and hash=?", (hash_id,))
    api = c.fetchone()
    self.name = api[3]
    self.id = api[0]
    if api[5] == 'Pointer':
      type_spelling = api[4].split('(*)')
      c.execute("select distinct * from node where kind = 'CursorKind.TYPE_REF' and parent_hash=?", (api[0],))
      function_type = c.fetchone()
      if function_type is not None:
        self.type = {'type': function_type[3], 
                      'pointer': type_spelling[0].replace(function_type[3], '').strip() }
      else:
        self.type = {'type': type_spelling[0], 
                     'pointer': '' }
    else:
      raise Exception(api[0], 'is not function pointer')

  def constructParamString(self):
    param_list =[] 
    for param in self.param_detail:
      param_list.append(param.string + '  ' + param.name)

    return ', '.join(param_list)

  def _dumpAsAPI(self, file_d):
    file_d.write('%s %s CEF_CALLBACK %s (%s){\n' % (self.type['type'], self.type['pointer'], self.name, self.constructParamString() ))
    file_d.write('\treturn %s(%s)\n' % (golang_prefix + self.name , ','.join([ i.name for i in self.param_detail ])))
    file_d.write('}\n\n')

  def _dumpAsHandlerGetter(self, file_d):
    file_d.write('%s %s CEF_CALLBACK %s(%s){\n' % (self.type['type'],  self.type['pointer'], self.name, self.constructParamString()) )
    file_d.write('\treturn NULL;\n')
    file_d.write('}\n\n')

  def DumpC(self, file_d):
    if self.Purpose is Function.API or Function.STRUCT_METHOD:
      self._dumpAsAPI(file_d)
    else:
      self._dumpAsHandlerGetter(file_d)

  def DumpGo(self, all=False):
    raise Exception('Dump Go is Not Implemented')


# this thing require some human touch. 
# def generate_function():
#   c.execute("select * from node where file = 'cef_app_capi.h' and kind = 'CursorKind.FUNCTION_DECL'")
#   for row in c.fetchall():
#     print row[3], ':', row[4].split(' ')[0]
#     for param in c.execute("select * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and parent_hash=?", (row[0],)):
#       print '-', param[3], ':', param[4].split(' ')[0]
#    #with open(file_go) as f:


# def c_generate_base_api():
#   c.execute("select * from node where file = 'cef_base_capi.h' and kind = 'CursorKind.TYPEDEF_DECL'")
#   for row in c.fetchall():
#     print row[3], ':', row[4]
#     c.execute("select * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and parent_hash=?", (row[0],))
#     h = c.fetchone()
#     for param in c.execute("select * from node where kind != 'CursorKind.UNEXPOSED_ATTR' and parent_hash=?", (h[0],)):
#       print '-', param[3], ':', param[4]
#        #with open(file_go) as f:
  

### old code 
def go_generate_type_wrapper(data_type, implemented_type):
  data_type = list(set(data_type))
  implemented_type = list(set(implemented_type))

  # these value should be removed because they are platform specific.
  # parser can't extract thier information across all platform. 
  platform_dependent = ['cef_window_info_t',
                        'cef_string_t']

  external_implement = ['_cef_browser_settings_t',
                        '_cef_screen_info_t']
  remove_list = implemented_type + platform_dependent + external_implement

  def remove_implemented(item):
    for ite in remove_list:
      if re.search(ite.strip(), item.strip()) is not None:
        return False
    
    # only get relavent type
    if re.match('struct', item.strip()) or re.match('cef_', item.strip()):
      return True
    
    return False

  temp_list = filter(remove_implemented, data_type)
  
  for item in temp_list:
    if re.match('struct', item.strip()):
      go_wrapper.append(item.strip())
    elif re.match('cef_', item.strip()):
      go_enum.append(item.strip())

  # with open(file_go, 'a+') as f:
  for item in go_wrapper:
    go_wrap_type(item)

  for item in go_enum:
    pass
    # print item 

def go_wrap_type(item):
  type_ref = item.split(' ')[1][1:] 
  # print type_ref
  with open(file_c, 'a+') as f:
    c.execute("SELECT DISTINCT * from node where spelling=? and kind = 'CursorKind.TYPEDEF_DECL'", (type_ref,))
    row = c.fetchone()
    struct_info = collect_struct_info(row[0])
    # pprint(struct_info)

# todo for char* 
    for api in struct_info['api']:
      print('%s %s_%s(%s){\n' % (api['type'], type_ref, api['name'], api['parameter_string']))
      param_list = [ param['name'] for param in api['parameter'] ]
      print('\treturn self->%s(%s);\n' % (golang_prefix+api['name'], ','.join(param_list)))
      print('}\n\n')
          
      # #app_api_initializer
      # f.write('void %s( %s * self ){\n' % (init_prefix+struct_info['name'], struct_info['type']))
      # f.write('\tself->base.size=sizeof(%s);\n' % (struct_info['type']))
      # f.write('\tinitialize_cef_base((cef_base_t*) self);\n')
      # for api in struct_info['api']:
      #   f.write('\tself->%s = %s;\n' % (api['name'], api['name']))
      # f.write('}\n\n')

if __name__ == '__main__':
  '''
  script use to generate c to golang binding
  it will contain alot of error, but will be modified as fit.
  '''
 
  parser = OptionParser("usage: %prog {filename} [clang-args*]")
  parser.disable_interspersed_args()
  (opts, args) = parser.parse_args()

  if len(args) == 0:
      parser.error('invalid number arguments')

  index = Index.create()
  tu = index.parse(None, args)
  if not tu:
      parser.error("unable to load input")

  # reset_db()
  # save_node(tu.cursor, None)
  # pprint(dump_node(tu.cursor, None))
  # generate_function()
  # c_generate_base_api()

  prepare_file()

  struct_type = {}
  
  # app_api
  c.execute("select * from node where file = 'cef_app_capi.h' and kind = 'CursorKind.TYPEDEF_DECL'")
  for row in c.fetchall():
    struct_type[row[3]] = CefStructHandler(row[0])

  # client_api
  c.execute("select * from node where file = 'cef_client_capi.h' and kind = 'CursorKind.TYPEDEF_DECL'")
  for row in c.fetchall(): 
    struct_type[row[3]] = CefStructHandler(row[0])

  # cef_handler
  temp_dict = {}
  # gather all handler
  for struct in  struct_type:
    for api in struct_type[struct].function_pointer:
      if api.Purpose is Function.HANDLER_GETTER:
        type_name = api.type['type'].split(' ')[1][1:]
        c.execute("SELECT DISTINCT * from node where spelling=?", (type_name,))
        id = c.fetchone()
        temp_dict[type_name] = CefStructHandler(id[0])
        # print type_name

  struct_type.update(temp_dict)

  for k in struct_type.keys(): 
    print k

  struct_type['cef_app_t'].DumpC()
  struct_type['cef_client_t'].DumpC()

  # temp_dict = {}
  # c.execute("SELECT DISTINCT * from node where kind = 'CursorKind.TYPEDEF_DECL' and spelling=?", ('cef_life_span_handler_t',))
  # id = c.fetchone()
  # temp_dict['cef_life_span_handler_t'] = CefStructHandler(id[0])
  # temp_dict['cef_life_span_handler_t'].dumpC()
  # go_generate_type_wrapper(data_type, struct_type)

  conn.close()
